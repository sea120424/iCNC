 /*

 Motion BLOCK :
 //************************
   Principle of interpolation (interpolar , INTP) 
   ´¡¸É­ì²z (¸É´¡¾¹)
   Coordinate management and calculation
   G00 / G01 as lineCmd in DEC_TO_INTP_Data : Input coordinates for X,Y,Z 
   G06 / G07 rotational angle 
   Coordinate input can be absolute or relative G90 / G91
   Feed F [mm/s]

 Function BLOCK :
 //*************************
   G04 dwell time
   M30 program end

 */


#include "StdAfx.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include < math.h>


#include "..\inc\intp.h"  // include user defined header file
#include "..\..\CNC\inc\cnc.h"


//INTP_DATA *intpDataPtr = &cncDataPtr->intpData;


INTP_DATA       *intpDataPtr;
extern CNC_DATA *cncDataPtr;
extern LINK_DATA *linkDataPtr;

//LINK_DATA       linkData;	                
//LINK_DATA       *linkDataPtr = &linkData;

//DEC_DATA        decData;	                
//DEC_DATA       *decDataPtr = &decData;




//extern int *cncDataPtr;
//***************************************************************
//
//***************************************************************

int intpInit(INTP_DATA *intpDataPtr)
					 //local data struct.generated by compiler after function call
	                 //  or more specifically, put the original intpDATA to stack of the function
{					
	clearByteSpace((char *)intpDataPtr, sizeof(INTP_DATA));
		
	intpDataPtr->cyclingTime = 0.03;    // 30 ms

	intpDataPtr->intpState = INTP_IDLE; // point to the next step
    return 1;
} // intpInit()


//***************************************************************
//
//***************************************************************
int intpIdle(INTP_DATA *intpDataPtr)
{
	// check if DEC_TO_LINK_BLOCK is Valid
	// if true , copy , reset block Valid
	// change to INTP_PRE
	// else do nothing

	if(linkDataPtr->decToIntpValid[linkDataPtr->readIndex] == true)
	{
		intpDataPtr->decToLinkBlock = linkDataPtr->decToLinkBlock[linkDataPtr->readIndex];
		linkDataPtr->decToIntpValid[linkDataPtr->readIndex] = false;
		linkDataPtr->decToIntpValid[linkDataPtr->writeIndex] = true;

		linkDataPtr->readIndex++;

		if(intpDataPtr->decToLinkBlock.linkCmd ==  M30_PROG_END)
	       intpDataPtr-> intpState = INTP_M30_PROGRAM_END;
	    else if(intpDataPtr->decToLinkBlock.linkCmd ==  G00_CMD)
	       intpDataPtr-> intpState = INTP_PRE;
		else if(intpDataPtr->decToLinkBlock.linkCmd ==  G04_DWELL_TIME)
		   intpDataPtr-> intpState = INTP_DWELL_TIME;
	}


	/*
	if(intpDataPtr->decToLinkBlock.decToLinkDataValid == true)
	{

	}
	*/

	/*
	Read decToIntpBlock,
	 if true,check the command type of block
	   if lineCmd = G00_Motion 
	   State INTP_PRE,INTP_EXE,INTP_CLOSE
	   if lineCmd = function: G04_DWELL_TIME ,M30_PROGRAM_END
	//execution of real-function:

	INTP_IDLE
	  Read new block from LINK_DATA
	  If true, check lineCmd in new decToIntpBlock,
	     if G00_MOTION,change state to INTP_PRE,return
		 else if G04_DWELL_TIME
		   if true,
		   {  
		       Init counter; counter = dwellTime/real-time timer cycling time;
			   Change state to INTP_DWELL_TIME

		   }
		 else if M30_PROGRAM_END
		 {
		      Change state to INTP_M30_PROGRAM_END
		 }


	*/


	/*char testFileName[200];

	if(cncDataPtr->linkData.linkToDecData.linkToDecDataValid == true)
	{
		if(cncDataPtr->linkData.linkToDecData.ncFileValid == true\
			&& cncDataPtr->linkData.linkToDecData.START == true)
		{
			cncDataPtr->linkData.linkToDecData.START = false;

			intpDataPtr->intpState = INTP_OPEN_NC_FILE;
		}

		cncDataPtr->linkData.linkToDecData.ncFileValid = false;
	}
	*/
	//strcpy(testFileName, cncDataPtr->linkData.linkToDecData.ncFileName);
	
   return 1;
} // intpIdle()


//G00 Linear motion solved by INTP_PRE, INTP_EXE, INTP_CLOSE
//G06/G07 rotation :


//*********************************************************
//
//*********************************************************
int intpPre(INTP_DATA   *intpDataPtr)
{

	
	/*
		Build absolute coordinate for startPos,
		relLength[] = endPos[] - startPos[]
		totalLength = sqrt(sigma(relLength*relLength))
		linearFactor[] = relLength[] / totalLength

		clear datas
		sumLength = 0 ; residualLength = totalLength
		change state to IDLE		
	*/
	
	
  return 1;
} // intpPre()

//*********************************************************
//
//*********************************************************

int  intpExe(INTP_DATA *intpDataPtr)
{   
	
	cncDataPtr->linkData.intpToLinkData.CarCoordinate[0] = intpDataPtr->nowPos[0];
	cncDataPtr->linkData.intpToLinkData.CarCoordinate[1] = intpDataPtr->nowPos[1];
	cncDataPtr->linkData.intpToLinkData.CarCoordinate[2] = intpDataPtr->nowAngel;



	// backup new = old
	// calculate new coordinate in real-time 
	//{
	//this cycle goes delta S,caculate sum_delta_length = sigma delta_s,
	//caculate residual length = total_length - sum_length

	// backup old position : oldPos[] = newPos[]
	//caculate coordinates using absolute sum_length
	//                       newPos = ......
	//to sheck if the motion is to end in next cycle
	//end in next cycle if Residual length <= delta_S
	//}



	// sumLength = sumLength + cyclingTime * momtSpeed
	// newPro[] = staryPro[] + linearFactor[] * sumLength
	// -> newPro[] = staryPro[] + linearFactor[] * cyclingTime * momtSpeed * sumLength
	// Determine block to end 


   return 1;
} // intpExe()


//*********************************************************
//
//*********************************************************

int intpClose(INTP_DATA   *intpDataPtr)
{
	// oldPos[] = newPos[]
	// newPos[] = endPos[]
	// send endPos[] 
	// cacu relLength for project
	//change to INTP_IDLE

  return 1;
} //intpWriteOut()

//*********************************************************
//
//*********************************************************

int intpError(INTP_DATA   *intpDataPtr)
{
	 return 1;
}


//*********************************************************
//
//*********************************************************

int intpDwellTime(INTP_DATA   *intpDataPtr)
{
/*	int Counter;
	Counter--;
	//if counter <= 0 -> change to INTP_IDLE
	*/
	 return 1;
}

//*********************************************************
//
//*********************************************************

int intpM30ProgramEnd(INTP_DATA   *intpDataPtr)
{
	//End of NC file,...
	//Broadcasting M30 to all modules: pass to linkMain() or sysMain() to all modules
	//change to INTP_IDLE

	 return 1;

}//intp -> sys -> dec
 //            -> mmi -> form set M30 lamp                  




//*********************************************************
//
//*********************************************************
int intpMain(INTP_DATA   *intpDataPtr)
{
	switch (intpDataPtr->intpState)
	{
	   case INTP_INIT:
		  intpInit(intpDataPtr);
		  break;
	   case INTP_IDLE:
		   intpIdle(intpDataPtr);
		   break;
	   case INTP_PRE:
		   intpPre(intpDataPtr);
		   break;
	   case INTP_EXE:
		   intpExe(intpDataPtr);
		   break;
	   case INTP_CLOSE:
		   intpClose(intpDataPtr);
		   break;
	   case INTP_DWELL_TIME:
		   intpDwellTime(intpDataPtr);
		   break;
	   case INTP_M30_PROGRAM_END:
		   intpM30ProgramEnd(intpDataPtr);
		   break;
	  default:INTP_ERROR;
		   intpError(intpDataPtr);
		   break;
	} // intpState
	//INTP send coordinate data in newsPos to MMI/FORM
	//INTP->MMI


	//attention!!!! free dynamic buffer at end of intpording or after M30
	//free(intpDataPtr -> fileButter);

  return 1;
} // intpMain()

